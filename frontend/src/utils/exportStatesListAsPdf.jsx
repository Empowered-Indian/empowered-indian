import React, { useState } from "react";
import { Document, Page, Text, View, StyleSheet, Image, pdf } from "@react-pdf/renderer";
import { FiDownload } from "react-icons/fi";
import { formatINRCompact } from "./formatters";
import { colors, createBaseStyles, createExtendedStyles, getExportButtonStyles, getDisabledButtonStyles, utilBarStyleFor } from "./pdfUIStyles";

const baseStyles = createBaseStyles(StyleSheet);
const extendedStyles = createExtendedStyles(StyleSheet);
const styles = { ...baseStyles, ...extendedStyles };

export async function generatePdfWithOptions(data = [], options = {}) {
  const { fileName: fn, meta = {}, layout = "cards" } = options;
  const fileName = fn || `empowered_indian_mplads_report_${meta.key || "all"}_${new Date().toISOString().split('T')[0]}.pdf`;
  const docNode = <MyDocument data={data} meta={meta} layout={layout} />;
  const asPdf = pdf(docNode, { author: "Empowered Indian" });
  const blob = await asPdf.toBlob();
  const url = URL.createObjectURL(blob);
  const a = window.document.createElement("a");
  a.href = url;
  a.download = fileName;
  window.document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
  return true;
}

const MyDocument = ({ data = [], meta = {} }) => {
  const timestamp = new Date().toLocaleString();
  const totalAllocated = data.reduce((sum, s) => sum + (s.totalAllocated || 0), 0);
  const totalExpenditure = data.reduce((sum, s) => sum + (s.totalExpenditure || 0), 0);
  const totalWorksRecommended = data.reduce((sum, s) => sum + (s.recommendedWorksCount || 0), 0);
  const totalWorks = data.reduce((sum, s) => sum + (s.totalWorksCompleted || 0), 0);
  const topPerformers = [...data].sort((a, b) => (b.utilizationPercentage || 0) - (a.utilizationPercentage || 0)).slice(0, 3);
  const bottomPerformers = [...data].sort((a, b) => (a.utilizationPercentage || 0) - (b.utilizationPercentage || 0)).slice(0, 3);

  // Additional insights
  const avgUtilization = data.length > 0 ? data.reduce((sum, s) => sum + (s.utilizationPercentage || 0), 0) / data.length : 0;
  const maxUtilization = Math.max(...data.map(s => s.utilizationPercentage || 0));
  const minUtilization = Math.min(...data.map(s => s.utilizationPercentage || 0));
  const highUtilStates = data.filter(s => (s.utilizationPercentage || 0) >= 80).length;

  // Helper function to chunk array into groups of n
  const chunkArray = (array, chunkSize) => {
    const chunks = [];
    for (let i = 0; i < array.length; i += chunkSize) {
      chunks.push(array.slice(i, i + chunkSize));
    }
    return chunks;
  };

  const stateChunks = chunkArray(data, 12);

  return (
    <Document>
      {/* First Page - Summary, Insights, Chart */}
      <Page size="A4" style={styles.page} orientation={meta.orientation || "portrait"}>
        <View style={styles.header}>
          <View style={styles.headerGradient} />
          <View style={styles.headerAccent} />
          <View style={styles.headerRow}>
            <Image style={styles.logo} src="https://avatars.githubusercontent.com/u/230681844?s=200&v=4" />
            <View style={styles.titleBlock}>
              <Text style={styles.title}>Empowered Indian</Text>
              <Text style={styles.subtitle}>MPLADS State Performance Report</Text>
              <Text style={[styles.smallText, { marginTop: 2 }]}>Transparent • Data-Driven • Impactful</Text>
            </View>
            <View style={{ width: '135px' }}>
              <Text style={styles.timestamp}>{timestamp}</Text>
              <Text style={styles.generatedBy}>Generated by Empowered Indian</Text>
            </View>
          </View>
        </View>
        <View style={styles.content}>
          <View style={styles.summary}>
            <View style={styles.summaryHeader}>
              <View style={styles.summaryIcon} />
              <Text style={styles.summaryTitle}>Average Performance Summary</Text>
            </View>

            <View style={styles.summaryGrid}>
              <View style={styles.summaryColumn}>
                <View style={styles.summaryMetric}>
                  <Text style={styles.summaryMetricLabel}>Total Allocated</Text>
                  <Text style={styles.summaryMetricValue}>{formatINRCompact(totalAllocated)}</Text>
                  <Text style={styles.summaryMetricSub}>Across {data.length} states</Text>
                </View>
                <View style={styles.summaryMetric}>
                  <Text style={styles.summaryMetricLabel}>Total Expenditure</Text>
                  <Text style={styles.summaryMetricValue}>{formatINRCompact(totalExpenditure)}</Text>
                  <Text style={styles.summaryMetricSub}>
                    {totalAllocated > 0 ? ((totalExpenditure / totalAllocated) * 100).toFixed(1) : 0}% of allocation
                  </Text>
                </View>
              </View>

              <View style={styles.summaryColumn}>
                <View style={styles.summaryMetric}>
                  <Text style={styles.summaryMetricLabel}>Total Works Completed</Text>
                  <Text style={styles.summaryMetricValue}>{totalWorks.toLocaleString()}</Text>
                  <Text style={styles.summaryMetricSub}>
                    {totalWorksRecommended > 0 ? ((totalWorks / totalWorksRecommended) * 100).toFixed(1) : 0}% completion rate
                  </Text>
                </View>
                <View style={styles.summaryMetric}>
                  <Text style={styles.summaryMetricLabel}>Total Works Recommended</Text>
                  <Text style={styles.summaryMetricValue}>{totalWorksRecommended.toLocaleString()}</Text>
                  <Text style={styles.summaryMetricSub}>Pending implementation</Text>
                </View>
              </View>
            </View>

            <View style={styles.performers}>
              <View style={styles.performerCol}>
                <Text style={styles.performerTitle}>★ Top Performers</Text>
                {topPerformers.map((s, i) => (
                  <Text key={i} style={i === topPerformers.length - 1 ? styles.performerItemLast : styles.performerItem}>
                    {i + 1}. {s.state} — {String((s.utilizationPercentage || 0).toFixed(1))}%
                  </Text>
                ))}
              </View>
              <View style={styles.performerCol}>
                <Text style={styles.performerTitle}>Areas for Improvement</Text>
                {bottomPerformers.map((s, i) => (
                  <Text key={i} style={i === bottomPerformers.length - 1 ? styles.performerItemLast : styles.performerItem}>
                    {i + 1}. {s.state} — {String((s.utilizationPercentage || 0).toFixed(1))}%
                  </Text>
                ))}
              </View>
            </View>
          </View>

          <View style={styles.insights}>
            <View style={styles.insightsHeader}>
              <View style={styles.insightsIcon} />
              <Text style={styles.insightsTitle}>Key Insights</Text>
            </View>
            <View style={styles.insightsGrid}>
              <View style={styles.insightCard}>
                <Text style={styles.insightValue}>{avgUtilization.toFixed(1)}%</Text>
                <Text style={styles.insightLabel}>Average Utilization</Text>
              </View>
              <View style={styles.insightCard}>
                <Text style={styles.insightValue}>{maxUtilization.toFixed(1)}%</Text>
                <Text style={styles.insightLabel}>Highest Utilization</Text>
              </View>
              <View style={styles.insightCard}>
                <Text style={styles.insightValue}>{minUtilization.toFixed(1)}%</Text>
                <Text style={styles.insightLabel}>Lowest Utilization</Text>
              </View>
              <View style={styles.insightCard}>
                <Text style={styles.insightValue}>{highUtilStates}</Text>
                <Text style={styles.insightLabel}>States ≥80% Util</Text>
              </View>
            </View>
          </View>

          <View style={styles.chart}>
            <View style={styles.chartHeader}>
              <View style={styles.chartIcon} />
              <Text style={styles.chartTitle}>Utilization Overview</Text>
            </View>
            <View style={styles.chartContainer}>
              {data.slice(0, 8).map((s, i) => {
                const pct = s.utilizationPercentage || 0;
                const height = Math.max(10, (pct / 100) * 100);
                return (
                  <View key={i} style={styles.chartBar}>
                    <View style={[styles.chartBarFill, { height }]}>
                      <Text style={styles.chartValue}>{pct.toFixed(0)}%</Text>
                    </View>
                    <Text style={styles.chartLabel}>{s.state}</Text>
                  </View>
                );
              })}
            </View>
          </View>
        </View>
      </Page>

      {/* State Data Pages - 10 states per page in card view */}
      {stateChunks.map((chunk, pageIndex) => (
        <Page key={pageIndex} size="A4" style={styles.page} orientation={meta.orientation || "portrait"}>
          <View style={styles.content}>
            <View style={styles.cardsContainer}>
              {chunk.map((s, i) => {
                const pct = Number(s.utilizationPercentage || 0);
                const fillStyle = utilBarStyleFor(pct, styles);
                const utilColor = pct >= 80 ? colors.success : pct >= 50 ? colors.warning : colors.accent;
                return (
                  <View key={i} style={styles.card}>
                    <View style={styles.stateLeft}>
                      <Text style={styles.stateName}>{s.state}</Text>
                      <Text style={styles.mpBadge}>MPS: {s.mpCount ?? 0}</Text>
                    </View>

                    <View style={styles.metricsRight}>
                      <View style={styles.metricBlock}>
                        <Text style={styles.metricLabel}>ALLOCATED</Text>
                        <Text style={styles.metricValue}>{formatINRCompact(s.totalAllocated ?? 0)}</Text>
                      </View>

                      <View style={styles.metricBlock}>
                        <Text style={styles.metricLabel}>EXPENDITURE</Text>
                        <Text style={styles.metricValue}>{formatINRCompact(s.totalExpenditure ?? 0)}</Text>
                      </View>

                      <View style={styles.utilBlock}>
                        <Text style={styles.metricLabel}>UTILIZATION</Text>
                        <Text style={[styles.utilLabel, { color: utilColor }]}>
                          {pct.toFixed(1)}%
                        </Text>
                        <View style={styles.utilBarOuter}>
                          <View style={[fillStyle, { width: `${Math.max(0, Math.min(100, pct))}%` }]} />
                        </View>
                      </View>

                      <View style={styles.metricBlock}>
                        <Text style={styles.metricLabel}>WORKS DONE</Text>
                        <Text style={styles.metricValue}>{s.totalWorksCompleted ?? 0}</Text>
                      </View>

                      <View style={styles.metricBlock}>
                        <Text style={styles.metricLabel}>WORKS RECOMMENDED</Text>
                        <Text style={styles.metricValue}>{s.recommendedWorksCount ?? 0}</Text>
                      </View>
                    </View>
                  </View>
                );
              })}
            </View>
          </View>

          {pageIndex === stateChunks.length - 1 && (
            <View style={styles.footer}>
              <View style={styles.footerLeft}>
                <Image style={styles.footerLogo} src="https://avatars.githubusercontent.com/u/230681844?s=200&v=4" />
                <Text style={[styles.smallText, { marginTop: 2, fontSize: 7 }]}>
                  * Data sourced from official MPLADS records. For latest updates, visit empoweredindian.in
                </Text>
              </View>
            </View>
          )}
        </Page>
      ))}
    </Document>
  );
};

const ExportStatesListAsPdf = React.forwardRef(({ filteredStates = [], meta = {}, layout = "cards" }, ref) => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [currentFilteredStates, setCurrentFilteredStates] = useState(filteredStates);

  React.useEffect(() => {
    setCurrentFilteredStates(filteredStates);
  }, [filteredStates]);

  React.useImperativeHandle(ref, () => ({
    updateFilteredStates: (newStates) => {
      setCurrentFilteredStates(newStates);
    }
  }));

  if (!currentFilteredStates || currentFilteredStates.length === 0) {
    return (
      <button
        disabled
        style={getDisabledButtonStyles()}
      >
        <FiDownload /> No data to export
      </button>
    );
  }

  const handleClick = async () => {
    setError(null);
    setLoading(true);
    try {
      await generatePdfWithOptions(currentFilteredStates, {
        fileName: `empowered_indian_mplads_report_${meta.key || "all"}_${new Date().toISOString().split('T')[0]}.pdf`,
        meta,
        layout,
      });
    } catch (e) {
      console.error("PDF generation failed", e);
      setError("Failed to generate PDF");
    } finally {
      setLoading(false);
    }
  };

  return (
    <button
      onClick={handleClick}
      disabled={loading}
      style={getExportButtonStyles(loading)}
    >
      <FiDownload />
      {loading ? "Generating PDF..." : error ? "Export Failed" : "Download Report"}
    </button>
  );
});

export default ExportStatesListAsPdf;